SSH 작업에서 포트 번호 열려고 할때는 주의해야 한다. (22번 포트)

템플릿 사용 이유 : 클라이언트가 보기에도 형식만 알면 이해할 수 있도록 하려고

-   Stateless(무상태성)
    
    이와 비교되는 개념이 **Stateful**
    
    Stateful과 Stateless는 모두 **네트워크 프로토콜**로, 클라이언트와 서버간의 네트워크 통신이 어떻게 이루어지는지에 대한 개념이다.
    
    -   **세션 상태** : 클라이언트와 서버간 통신 인증이 된 상태, 이 상태에서 데이터 송수신이 가능하다
        
    -   **세션 정보** : 한 세션 내에서 클라이언트가 서버에 전송할 데이터 정보, 서버는 세션 유지 기간이 지나거나 클라이언트가 전송하려했던 데이터를 모두 수신할 때까지 클라이언트와 세션 상태를 유지함
        
    -   Stateful
        
        **세션이 종료될 때까지 클라이언트의 세션 정보를 저장하는 네트워크 프로토콜**
        
        ex : TCP 프로토콜, 온라인 뱅킹
        
        -   장점 : 통신이 중단되더라도 중단된 곳에서 다시 시작 가능
            
        -   단점 : 확장성이 좋지 않음
            
            → 세션 정보가 새로 scale out 된 서버에 저장 되어 있지 않음
            
            → scale out 시 클라이언트의 세션 정보를 새로운 서버로 옮겨주는 등의 부수적인 관리가 요구됨
            
    -   Stateless
        
        **서버가 클라이언트의 세션 상태 및 세션 정보를 저장하지 않는 네트워크 프로토콜**
        
        -   요청에 대한 응답만 처리한다.
        -   각 통신은 선행되거나 후속으로 따라오는 통신과 관련이 없다.
        -   클라이언트가 송신하려 했던 모든 데이터가 서버쪽에 수신되었는지 확인하지 않음
        
        ex : UDP 프로토콜, 온라인 검색
        
        -   장점 : 확장성이 좋음
        -   클라이언트 측에서 송신할 데이터의 양이 많아짐
-   Request Header를 활용한 로그인 방식
    
    -   Request Header
        
        HTTP 요청에 사용되지만 메시지의 컨턴츠와는 관련이 없는 HTTP 헤더
        
    
    그냥 단순히 이 Request Header에 계정 정보를 넣어서 로그인을 구현한다.
    
    http 방식으로 보내는데, 이를 탈취하면 손쉽게 개인정보를 받을 수 있기 때문에 사용되지 않는다.
    
    -   인증 Autentication
        
        식별 가능한 정보로 서비스에 등록된 유저의 신원을 입증하는 과정
        
    -   인가 Authorization
        
        인증된 사용자에 대하여 자원의 접근 권한을 확인하는 것
        
-   쿠키
    
    HTTP 쿠키, 웹 쿠키, 브라우저 쿠키
    
    -   **서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각**
        
    -   클라이언트 단에서 **저장을 하는 storage의 이름**
        
        브라우저는 이 데이터 조각을 저장해 두었다가 동일한 서버 재요청시 저장된 데이터를 함께 전송
        
    
    **쿠키 사용 목적**
    
    주로 두 요청이 동일한 브라우저에서 들어왔는지를 판단할 때 사용된다.
    
    이를 통해 사용자 로그인 상태를 유지할 수 있다.
    
    → Stateless HTTP 프로토콜에서 상태 정보를 기억해주기 때문
    
    -   세션 관리 : 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리
    -   개인화 : 사용자 선호, 테마 등의 세팅
    -   트래킹 : 사용자 행동을 기록하고 분석
    
    쿠키 안에 Session_id 를 저장할 수 있음 쿠키의 이름도 지정 가능
    
    현재는 쿠키 보다 mordern storage API들을 사용해 정보를 저장하는 것을 권장함
    
    ex : 웹 스토리지 API와 IndexedDB
    
-   쿠키를 활용한 로그인 방식
    
    로그인 상태 유지 방법
    
    -   로그인에 성공하면 특정이름을 갖는 쿠키를 생성
    -   해당 쿠키가 존재하면 로그인한 상태라고 판단
    -   로그아웃하면 해당 쿠키를 삭제
    
    보안 문제점
    
    -   쿠키 값을 임의대로 변경할 수 있다.
    -   쿠키에 보관도니 정보(memberId)를 타인이 훔쳐갈 수 있다.
    -   한 번 도용된 쿠키 정보는 계속 악용될 수 있다.
    
    문제점을 해결하기 위해서는 중요 정보들의 경우 클라이언트가 아니라 서버에서 관리하도록 하고 외부 노출을 막아야 한다.
    
    클라이언트는 서버가 보관하고 있는 중요 정보에 접근할 수 있는 키만 가지고 있고, 이 키 또한 유효시간을 짧게 둬서 갱신이 되도록 하면 보안적으로 많이 안전해진다. 그리고 이 방법을 세션으로 한다.
    
-   세션
    
    사용자가 브라우저를 통해 웹 서버에 접속한 시점부터 종료하는 시점까지 일련의 요청을 하나의 상태로 보고
    
    그 상태를 일정하게 유지시키는 기술
    
    브라우저를 끄면 삭제됨, 기간을 지정할 수 있음
    
    웹 서버 상에서 리소스를 사용, 쿠키보다 느림 대신 보안이 조금더 좋다.
    
-   세션을 활용한 로그인 방식
    
    로그인 상태 유지 방법
    
    -   로그인에 성공하면 서버의 세션 저장소에 key/value 형태로 저장한다.
    -   브라우저는 key값을 가진다. (쿠키에 저장)
    -   다음 접근 시, 서버는 해당 key의 alue값을 조회해서 로그인 여부와 중요 정보를 확인한다.
    
    문제점
    
    -   세션을 서버에 저장해야 하므로 비효율적
    -   서버 확장 시 서버간에 세션을 공유하기 어려움
-   OAuth
    
    소셜 로그인
    
    어떤 정보를 보낼지도 다 체크를 하게 되어있다. Permissino List
    
    클라이언트가 유저가 만든 퍼미션 리스트를 받아서 서버에 넘겨주면
    
    서버는 해당 소셜에 퍼미션 리스트를 보냄 (토큰 포함)
    
    그러면 그 소셜은 퍼미션 리스트에 포함된 값만 응답
    
-   JWT(Json Web Token)
    
    사용자의 정보가 암호화 되어있는 문자열
    
    로그인을 하면 서버가 토큰을 만들어서 사용자에게 넘겨줌
    
    서버는 토큰으로 인증된 사용자인지 판단
    
    이렇게 인증하는 방식이 표준 인증 방식이다.
    
    API를 호출할 때 마다 권한 검사를 한다.
    
    클라이언트가 서버에 ID, PWD를 넘겨주면
    
    서버는 JWT를 클라이언트에 넘겨준다.
    
    여기에는 Header, Payload, Signature가 포함되어 있다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab5df680-a7b0-40b0-bbca-7f7a62c23ff3/Untitled.png)
    
    페이로드에는 아이디, 패스워드가 들어있고 기간이 설정되어 있음
    
    시그니처에는 secret_key, 암호화키가 저장되어 있음 이 키를 통해서만 저장할 수 있도록 함
    
    자동 로그인을 할 경우, 아이디와 패스워드를 보내지 않고 JWT 를 서버에 보낸다.
    
    세션으로 로그인 하는 방식의 단점을 해결하기 위한 방법이 **토큰 기반의 사용자 인증 방법**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad1ab0a1-8f8d-429b-a8ac-01af1d5558cf/Untitled.png)
    
    1.  사용자는 id(or email)과 password를 입력하고 서버로 요청을 보낸다.
    2.  서버는 db에서 회원을 조회하고 등록된 사용자인지 확인
    3.  등록된 사용자라면 서버는 토큰을 생성하고 프론트로 토큰과 함께 응답을 보낸다.
    4.  응답이 성공적으로 왔다면 로그인(인증) 성공 → 이후 요청에서는 토큰을 함께 보낸다.
    5.  서버는 로그인 이후에 요청에 함께 실려온 토큰을 검증하고, 검증에 성공하면 요청된 데이터를 응답(인가)
    
    특징
    
    -   무상태성
    -   확장성
    -   무결성
    -   보안성
-   Paging 처리
    
    -   Paging
        
        사용자가 어떠한 데이터를 필요로 할 때, 전체 데이터 중의 일부를 보여주는 방식
        
        게시판에서 글이 많으면 다음 페이지로 넘어가는 바로 그것
        
        인스타 무한 스크롤
        
    -   Spring에서 Paging 처리
        
        -   페이징을 담당할 PagingVO를 만든다 (util)
            -   보여지는 시작과 끝 페이지, 제일 마지막 페이지를 계산하는 메소드
            -   DB 쿼리에서 사용할 start, end 값 계산 메소드
        -   게시판 Mapper에 페이징 처리하는 쿼리를 게시글 조회에 넣는다. BoardMapper.xml
        -   해당 Mapper, Service, Controller에 메소드들을 생성해 연결
    
    참고 링크
    
    [[Spring] 스프링 게시판 만들기 - 페이징(Paging) 처리하기](https://po9357.github.io/spring/2019-05-28-Board_Paging/)
    
    10개씩 끊고 싶을 때 쿼리
    
    ```sql
    select * from [table] orders limit 10;
    ```
    
    -   limit 구문
        
        숫자를 두 개 쓸 수 있다. offset, number
        
        ```sql
	select * from [table] orders limit 10 offset 0;
	select * from [table] orders limit 10 offset 10;
        ```
        
        차례로 1페이지, 2페이지 조회
        
    
    주의! 그런데 그냥 이렇게 하면 새로운 게시글이 빨리올라오는 서비스의 경우
    
    페이지를 넘겨도 계속 같은 글을 보게될 수 있다.
    
    맨 처음 스크롤 했을 때 마지막 인덱스를 기준으로 다음 것을 보여주면 된다!
    
-   Local Storage
    
    모든 플랫폼에 존재하는 클라이언트 저장소(클라이언트는 MySQL을 사용할 수 없다.)
    
    JWT를 여기에 저장한다. 자동 로그인할 때 이 저장소에서 JWT를 가져와서 로그인
    
    로그아웃시 저장소에 JWT를 삭제한다. → 서버는 로그아웃 API를 만들 필요가 없다.
    
    로컬에서 저장하면 편한 값들은 여기에 저장한다.
    
-   Transaction
    
    데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위
    
    -   데이터베이스의 상태를 변화시킨다는 것?
        
        == SQL을 이용하여 데이터베이스에 접근하는 것
        
    
    이때 작업의 단위는 질의어 한문장이 아니라는 것을 주의하자!
    
    많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것
    
    ex : 게시판에 글을 올리고 글이 올려졌는지 확인 → insert 문 + select문
    
    트랜잭션 설계를 잘하는 것이 데이터를 다루는 것에 많은 이점이 있다.
    
    -   특징
        -   원자성 : 트랜잭션이 데이터베이스에 모두 반영이 되거나 전혀 반영이 되지 않아야
        -   일관성 : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야
        -   독립성 : 트랜잭션 연산 중간에 다른 트랜잭션이 끼어들 수 없다.
        -   지속성 : 트랜잭션이 성공적으로 완료되면 결과는 영구히 반영되어야
    
    트랜잭션의 반영, 취소를 COMMIT, ROLLBACK 연산으로 진행 가능